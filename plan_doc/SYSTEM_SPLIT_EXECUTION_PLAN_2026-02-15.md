# EduX 분리/ML 적용 실행계획서 (정교화)

작성일: 2026-02-15
적용 시작점: 현재 운영/개발 중인 `edux` 사이트 (`d:\workSpace\edux`)

## 실행 순서 (바로 적용용 번호)

아래 순서대로 진행하면 된다. 각 단계 완료 후 다음 단계로 이동한다.

1. `STEP 01` 경계 확정: Core/Generation 책임과 소유 팀 확정
2. `STEP 02` 이벤트 스키마 v1 확정: 필수 필드/버전/PII 처리 규칙 확정
3. `STEP 03` Core 이벤트 발행 구현: 과정/승인/공유/외부링크 이벤트 우선 적용
4. `STEP 04` 데이터마트 적재 파이프라인 구축: 운영 트랜잭션과 비동기 분리
5. `STEP 05` 관측 대시보드 오픈: KPI 기준선(승인율/공유수락률/실패율) 측정 시작
6. `STEP 06` Generation 최소 골격 배포: Job API(`outline`,`draft`) + 상태조회
7. `STEP 07` Core UI 연동: Job 요청/상태조회/재시도 액션 연결
8. `STEP 08` DM 변환 단계 추가: 파이프라인 중간 산출물 저장 및 추적
9. `STEP 09` 최종 렌더 단계 이관: 템플릿 조합/문서 생성/아티팩트 관리
10. `STEP 10` 경량 ML 실험: 추천/랭킹 A/B 테스트 및 효과 검증
11. `STEP 11` 파인튜닝 의사결정: ROI, 품질, 비용 기준 충족 시에만 착수
12. `STEP 12` 운영 고도화: 오류코드 표준화, 계약 테스트, 보안/보관 정책 정식화

---

## 0) 핵심 답변

질문: "이건 이 사이트에 적용으로 시작되는 거지?"

답변: **맞다.**
본 계획은 신규 독립 제품이 아니라, **현재 edux를 Core로 유지한 상태에서** 기능을 점진 분리/연동하는 실행안이다.

---

## 1) 목표와 비목표

### 목표

1. 현재 사이트의 기능 연속성을 깨지 않고 확장한다.
2. AI/문서생성 계열을 분리해 성능/유지보수 리스크를 줄인다.
3. 사이트 이벤트를 ML/추천/자동화에 재사용 가능한 데이터 자산으로 전환한다.

### 비목표

1. 단기간 내 전체 마이크로서비스 전환
2. 초기 단계에서 즉시 파인튜닝 중심 전략
3. 운영 DB를 학습 파이프라인이 직접 참조하는 구조

---

## 2) 현재 사이트 기준 진단 요약

코드 기준 주요 특성:

- `src/transport.ts`: OAuth, 파일업로드, 공유링크, MCP 툴 등록, 정적 서빙이 집중됨
- `src/mcp-server.ts` + `src/transport.ts`: MCP 툴 등록 중복 관리 지점 존재
- `src/workers/pdfWorker.ts`: 렌더 워커에 데이터 조회/변환/파일생성/문서저장 로직이 밀집
- `prisma/schema.prisma`: Core 도메인 + 렌더/문서 도메인이 단일 스키마에 결합

판단:

- 현재 구조는 "기능 확장"엔 빠르지만 "AI/파이프라인 대형화" 단계에서 결합도/변경 리스크가 커진다.

---

## 3) 대상 아키텍처 (2-덩어리 전략)

초기에는 2개로만 분리한다.

### A. Core App (현재 edux)

책임:

- 인증/인가/JWT/RBAC
- 사용자/그룹/권한 정책
- 코스/강의/강사/스케줄 CRUD
- 승인/공유/알림/외부 공유 링크 관리
- 생성 Job 요청 발행 및 결과 조회 UI

### B. Generation Platform (신규)

책임:

- AI 오케스트레이션(목차/원교안/원고)
- DM 변환
- 템플릿 조합/문서 렌더
- 장시간 Job 실행/재시도/DLQ/관측

연동 방식:

- Core -> Generation: 비동기 Job 생성 API
- Generation -> Core: 완료 이벤트(Webhook) 또는 상태 조회 API

---

## 4) 기능 배치표 (실행 기준)

| 기능 | 배치 | 비고 |
|---|---|---|
| 스케줄 기본 기능(CRUD, 권한, 조회) | Core | 현재 사이트에서 고도화 유지 |
| AI 목차 추천/자동 생성 | Generation | 비동기 Job |
| 목차별 원교안 생성 | Generation | 사용자 가이드 버전 반영 |
| 원교안 DM 변환 | Generation | 파이프라인 단계 분리 |
| 원고+템플릿+스킬가이드 교안 생성 | Generation | 렌더/아티팩트 저장 |
| 승인/공유/외부링크 관리 | Core | 정책/감사 책임 유지 |

---

## 5) 이벤트 기반 ML 적용 현실성 검토

결론: **현실성 높음**, 단 "파인튜닝 선행"은 비권장.

우선순위:

1. 이벤트 표준화
2. 학습 데이터마트 분리 구축
3. 라벨 정책 정의
4. 경량 ML(추천/랭킹) 운영
5. 효과 확인 후 파인튜닝 검토

### 5.1 ML에 유의미한 이벤트 후보

- course_created
- course_updated
- course_approved / course_rejected
- course_share_invited / accepted / rejected
- document_render_requested / completed / failed
- external_link_opened
- external_link_downloaded
- revision_requested / revision_completed

### 5.2 라벨 예시

- 품질 라벨(weak): 승인 여부 + 재수정 횟수 + 공유 수락률
- 활용 라벨: 외부 링크 유효 열람(체류시간, 재방문)
- 생산성 라벨: 초안 대비 최종 확정 소요시간

---

## 6) 이벤트 데이터 계약 (초안)

모든 이벤트는 최소 아래 필드를 가진다.

```json
{
  "eventId": "uuid",
  "eventName": "course_approved",
  "occurredAt": "2026-02-15T12:00:00Z",
  "actorUserId": "u_xxx",
  "targetType": "course",
  "targetId": "c_xxx",
  "tenantId": "default",
  "requestId": "req_xxx",
  "payload": {},
  "schemaVersion": 1
}
```

원칙:

- 스키마 버전 필수
- PII는 payload에 직접 저장 금지(또는 마스킹)
- 학습용 적재는 운영 트랜잭션과 분리(비동기)

---

## 7) 주요 문제와 해결책 (실행 관점)

### 문제 1. 권한/소유권 판정 중복

- 해결: 권한 판정은 Core 단일 책임. Generation은 "검증된 요청"만 수락.

### 문제 2. 운영 DB 직접 의존 증가

- 해결: Generation은 Core API/이벤트로만 데이터 수급. 직접 join 최소화.

### 문제 3. 중복 Job/상태 꼬임

- 해결: idempotency key + 상태머신 + 재시도 정책 + DLQ.

### 문제 4. AI 비용 급증

- 해결: 입력해시 캐시, 버전 고정(model/prompt/template), 비용 대시보드.

### 문제 5. 개인정보/보안

- 해결: PII 마스킹, 보관기간 정책, 삭제권 반영, 접근 감사로그.

### 문제 6. 이벤트 품질 저하(봇/노이즈)

- 해결: 봇필터, 품질 스코어링, 유효세션 기준 라벨링.

### 문제 7. 품질 측정 부재

- 해결: 오프라인 + 온라인 KPI 이중 운영.

---

## 8) KPI 정의 (최소 세트)

### 제품 KPI

- 승인율
- 승인까지 평균 소요시간
- 공유 수락률
- 외부 링크 유효 열람률

### 생성/ML KPI

- 생성 성공률
- 재생성률(낮을수록 좋음)
- 단계별 실패율(outline/draft/dm/render)
- 단건 평균 비용/토큰

### 운영 KPI

- 큐 대기시간 P95
- Job 총 처리시간 P95
- 재시도율
- DLQ 유입률

---

## 9) 90일 실행 로드맵 (현실형)

### 0-30일

1. 이벤트 카탈로그/스키마 확정
2. Core에서 이벤트 발행(과정/승인/공유/링크)
3. 데이터마트 적재 파이프라인 구축
4. 대시보드(기본 KPI) 오픈

### 31-60일

1. Generation 서비스 최소 골격 구축
2. `outline`/`draft` Job API 오픈
3. Core UI에서 Job 요청/상태조회 연결
4. 실패재시도 + 알림 체계 도입

### 61-90일

1. DM 변환 + 최종 렌더 단계 연결
2. 경량 추천/랭킹 모델 실험(A/B)
3. 성과 검증 후 파인튜닝 착수 여부 결정

---

## 10) 적용 시 기술적 결정사항 (권장)

1. Job 상태 표준: `queued/running/completed/failed/canceled`
2. 표준 오류코드 도입: `GEN_*`, `AUTH_*`, `DATA_*`
3. correlationId 전 구간 전파
4. 이벤트 저장소는 append-only 원칙
5. API 계약 테스트(consumer-driven contract) 도입

---

## 11) 즉시 실행 체크리스트

- [ ] Core/Generation 책임 경계 문서 승인
- [ ] 이벤트 스키마 v1 승인
- [ ] 개인정보/학습 제외 정책 승인
- [ ] KPI 기준선 측정 시작
- [ ] Phase 1 범위 확정(목차 추천/자동 생성)

---

## 12) 최종 의견

현재 edux에 계속 기능을 누적하는 방식은 단기 생산성은 있으나,
AI/자동화가 늘어날수록 성능/운영/변경 리스크가 커진다.

따라서,

- **스케줄/승인/공유 같은 운영 도메인은 Core 고도화 유지**
- **AI/문서생성/변환 파이프라인은 분리 플랫폼으로 이관**
- **이벤트를 ML 자산으로 축적하고, 파인튜닝은 후행 판단**

이 순서가 가장 현실적이고 실패 확률이 낮다.

